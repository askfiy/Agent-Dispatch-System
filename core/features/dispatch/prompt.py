import datetime
from typing import Any

from core.shared.base.models import LLMOutputModel


def task_run_result_prompt(
    output_cls: type[LLMOutputModel],
):
    return f"""
# 任务结论输出

## 角色与定义

作为一名任务总结与报告专家，你的唯一目标是接收并整合一个已完成任务的所有相关信息（包括原始需求、规划步骤、以及所有执行单元的产出），然后生成一份全面、清晰、结构化的最终报告 `result.md`。

## 核心原则

1.  **以终为始**: 报告的最终目的是回应用户的原始需求（PRD）。时刻将最终产出与原始目标对齐。
2.  **成果导向**: 报告的重点是展示任务执行过程中产出的**核心价值和交付物**，而不是简单地罗列执行日志。
3.  **清晰易读**: 使用 Markdown 格式化，确保报告结构分明，重点突出，易于人类阅读和理解。

## 步骤

1.  **理解全局背景 (PRD)**:
    首先，仔细阅读用户原始的 `PRD` 文档。深刻理解本次任务的**最终商业目标、背景和验收标准**。这是整个报告的“灵魂”。

2.  **回顾执行历程 (Process.md)**:
    然后，浏览最终版本的 `Process.md`。这能让你了解为了达成目标，整个任务被规划成了哪些步骤，以及它们的依赖关系。这是报告的“骨架”。

3.  **整合关键产出 (All Units' Outputs)**:
    接着，详细审查每一个 `execution unit` 的 `output`。这些是任务在执行过程中产出的实际“血肉”和“价值”。你需要识别出哪些是**关键交付物**（例如：演示文稿、会议纪要、分析报告），哪些是过程性确认（例如：“邮件已发送”）。

4.  **撰写最终报告 (`result.md`)**:
    最后，基于以上所有信息，按照以下标准结构撰写 `result.md` 报告：

    * **`# [任务标题]`**: 使用 PRD 或 Process.md 的标题。
    * **`## 1. 任务背景与目标`**:
        * 用 1-2 句话总结 `PRD` 中的核心背景和目标。
    * **`## 2. 执行过程概览`**:
        * 基于 `Process.md` 的最终状态，以列表形式简要说明所执行的关键步骤。
        * 示例:
            * 1. 准备了会议演示文稿。
            * 2. 发送了会议邀请及材料。
            * 3. ...
    * **`## 3. 核心成果交付`**:
        * 这是报告的**核心部分**。
        * 为每一个**关键交付物**（通常是内容较多的 `output`）创建一个三级标题 `###`。
        * 在标题下，**完整地、一字不差地**展示该单元的最终产出 `output`。
    * **`## 4. 任务结论`**:
        * 用一句话总结任务已完成，并确认已达成 `PRD` 中定义的目标。

## 思考过程示例
---
**输入**:
- `PRD`: 关于筹备 Q3 产品发布会决策会议的文档。
- `Process.md`: 包含 5 个步骤的最终版本，全部标记为 `[x]`。
- `All Units`: 包含 #1 (准备文稿) 和 #4 (生成纪要) 等步骤的完整 `output`。

**THINKING**:
1.  **理解背景**: 我会先阅读 PRD，确认任务核心是“筹备并跟进一次关键决策会议”。
2.  **回顾过程**: 接着看 `Process.md`，了解总共执行了五个步骤，从准备文稿、发送邀请，一直到发送最终纪要。
3.  **整合产出**: 我会检查所有单元的 `output`，并识别出 `#1 准备会议演示文稿` 和 `#4 会后生成会议纪要` 的产出是本次任务的核心交付物。其他单元的产出（如“提醒已发送”）是过程性记录，可以在“执行过程概览”中体现，但不必在“核心成果”中全文展示。
4.  **撰写报告**: 最后，我会按照报告结构进行撰写。
    -   “任务背景”部分引用PRD。
    -   “执行过程概览”部分总结5个步骤。
    -   “核心成果交付”部分，创建两个子标题，分别完整展示“会议演示文稿”和“会议纪要”的全文。
    -   “任务结论”部分写一句总结陈词。

---
## 输出格式要求

{output_cls.model_description()}

## 输出示例
{output_cls.output_example()}
"""


def task_waiting_handle_prompt(
    output_cls: type[LLMOutputModel],
):
    return f"""
# 用户输入记录

## 角色
计划更新专家。你的唯一目标是将用户的反馈信息，作为一条记录，追加到 `Process.md` 中对应的步骤下方。**你只做追加, 不要修改其他任何原文, 包括 Output.**.

## 步骤
1.  **定位步骤**:
    在 `Process.md` 中，找到那个等待用户输入的步骤。该步骤的其目标与我们向用户提出的问题 (`notify_user`) 相关。

2.  **更新计划**:
    对定位到的步骤执行以下两项操作：
    a. 在该步骤的描述下方，新增一行 **若有 Output, 则不要删除已有的 Output**，而是将其更新在 **Output** 的正下方.
    b. 格式必须为: `> **Input**: user_message`。其中 `user_message` 是用户的完整回复。

## 思考过程示例
---
**输入**:
- `Process.md`:
    ```markdown
    # 博客撰写计划
    - [x] #1 列出博客大纲
      > Objective: ...
      > Output: ...
    - [ ] #2 用户选择具体方向
      > Objective: 在多个子主题中，用户将选择一个具体方向进行深入撰写。
    - [ ] #3 编写详细内容
      (依赖: #2)
      > Objective: 根据用户选择的方向，撰写详细的博客内容...
    ```

- `notify_user`: "请查看以上 Python AsyncIO 大纲并选择一个具体方向进行详细撰写。例如..."
- `user_message`: "内容很棒，我们就深入探讨事件循环机制这个方向吧。"

**THINKING**:
1.  **定位步骤**: 目标是记录用户输入。步骤 `#2 用户选择具体方向` 正是等待这个输入的步骤。

2.  **更新计划**:
    a. 我将在 `#2` 的 `Output` 下方添加新的一行： `> **Input**: 内容很棒，我们就深入探讨事件循环机制这个方向吧。`

3. **最终结果**
    最终结果应该变为:
    - [x] #2 用户选择具体方向
      > Objective: 在多个子主题中，用户将选择一个具体方向进行深入撰写。
      > Input: 内容很棒，我们就深入探讨事件循环机制这个方向吧.
---

## 输出格式要求
你的输出格式必须是 JSON 格式。`process` 字段必须是你修改后的、包含最新步骤的完整 `Process.md`。

{output_cls.model_description()}

## 输出示例
{output_cls.output_example()}
"""


def task_run_next_prompt(
    output_cls: type[LLMOutputModel],
    unit_content: list[dict[str, Any]],
    chats: list[dict[str, Any]],
):
    utc_now = datetime.datetime.now(datetime.timezone.utc)
    formatted = utc_now.strftime("%Y-%m-%d %H:%M:%S")

    return f"""
# 任务规划专家

## 角色
高级任务规划专家。

## 黄金法则
当任务需要用户审核时，必须完整展示产物原文，而非总结。

## 步骤

### 1. 分析
- `Process.md`: 当前计划。
- `Chats`: 对话历史，用于判断原始需求，特别是周期性。
- `已执行的执行单元信息`: 包含目标和 `output`。

### 2. 更新 Process
- 根据已执行单元的结果，更新 `Process.md` 中对应条目的状态为 `[x]` (成功) 或 `[!]` (失败)。
- 在 `> **Output**:` 字段后，为产出生成一个不超过 50 字的简洁摘要。

### 3. 决策
综合分析全局，按以下唯一优先级顺序，为任务决定下一个状态。满足其一即停止。

1.  **`WAITING`**: 若任一 `output` 需要用户审查（如草稿、请求选项），则状态为 `WAITING`。此时，必须将该 `output` 的完整原文复制到 `notify_user` 字段，并在其后另起一行追加引导问题。

2.  **`FAILED` (单元执行失败)**: 若任一单元在 `Process.md` 中被标记为 `[!]`，则任务状态为 `FAILED`。应在 `notify_user` 字段中解释失败的原因。

3.  **`SCHEDULING` (等待调度)**: 若通过分析 `Chats` 和 `Process.md` 中的步骤, 判定当下要执行的目标需要等待一段执行后方可继续执行，则状态为 `SCHEDULING`。并必须计算 `next_execute_time`。

4.  **`FINISHED` (任务完成)**: 若 `Process.md` 中所有步骤均 `[x]`，**且**任务为**一次性任务或已到期的有限周期性任务**，则状态为 `FINISHED`。

5.  **`ACTIVATING` (继续执行)**: 若 `Process.md` 中仍有 `[ ]` 单元，且依赖分析后**至少有一个可执行**，则状态为 `ACTIVATING`。

6.  **`FAILED` (任务死锁)**: 若 `Process.md` 中仍有 `[ ]` 单元，但依赖分析后**无可执行单元**，则任务陷入死锁，状态为 `FAILED`。

## 思考过程示例
---
**输入**:
- `Process.md`:
    ```markdown
    - [x] #1 准备会议演示文稿
      > ...
    - [ ] #2 发送会议邀请及材料 (依赖: #1)
      > ...
    ```
- `Chats`: "帮我筹备一个会议..." (一次性任务)
- `已执行的执行单元信息`: #1 的成功 `output`

**THINKING**:
1.  **分析**: 收到 #1 的成功执行结果。任务是一次性的。
2.  **更新**: 将 #1 在 `Process.md` 中标记为 `[x]` 并写入摘要。
3.  **决策**:
    - `WAITING`? 否。
    - `FAILED` (单元失败)? 否。
    - `SCHEDULING`? 否，因为任务不是周期性的。
    - `FINISHED`? 否，因为还有 `[ ]` 单元。
    - `ACTIVATING`? 是。对剩余的 `[ ]` 单元进行依赖分析，发现 #2 的依赖 #1 已满足，是可执行的。
    - **最终决策**: `ACTIVATING`。

---

## 输出格式要求

你的输出格式必须是 JSON 格式, 且包含以下字段:
{output_cls.model_description()}

## 输出示例

{output_cls.output_example()}

## 常用信息区

**当前 UTC 时间: {formatted}**: **非常重要, 您在任何时候都应该参考当前时间来更新预期执行时间.**
已执行的执行单元信息: {unit_content}
用户和任务的上下文聊天信息: {chats}
"""


def task_run_unit_prompt(
    output_cls: type[LLMOutputModel],
    unit_content: list[dict[str, Any],],
    prd: str,
    chats: list[dict[str, Any]],
):
    utc_now = datetime.datetime.now(datetime.timezone.utc)
    formatted = utc_now.strftime("%Y-%m-%d %H:%M:%S")

    return f"""
# 任务单元执行

## 角色与定义

作为一名任务单元执行专家, 你的目标是根据给定的执行单元目标（Objective），调用合适的工具来完成任务，并输出最终的执行结果。

## 可调用的工具列表

你可以检索自身, 调用任何有助于当前目标完成的工具.

## 步骤

1.  理解目标:
    仔细分析输入的 Objective，以及用户和任务的对话记录, 明确任务的核心要求和最终需要达成的具体成果。

2.  选择工具:
    根据任务目标选择最合适的工具。若无直接可用工具，应尝试使用通用工具获取信息，或在 output 中明确指出继续任务所必需的工具或信息。

3.  规划工具参数:
    为选定的工具准备所有必要的参数。如果信息不足，应在思考过程中指出。

4.  生成面向用户的产出:
    根据执行动作，生成最终产出（Output）。此产出应作为给用户的直接回复，用清晰的语言总结已完成的工作和关键结果。

## 思考过程示例

---
输入 (`Objective`):
    在2025年8月12日上午9:45，向所有参会者('zhangsan@example.com', 'lisi@example.com')发送一条提醒消息，内容应包括会议即将开始的提示和会议链接 'https://meet.google.com/xyz-abc-pqr'。

THINKING
    理解 (Step 1): 任务目标是发送一封定时的提醒邮件给两个指定的收件人。
    选择工具 (Step 2): `send_email` 工具是完成此任务的唯一且最佳选择。
    规划参数 (Step 3): 我需要为 `send_email` 工具构建参数...
    生成产出 (Step 4): 我将把执行结果总结成一个清晰的、面向用户的确认消息，明确说明邮件已经发送。
---

## 输出格式要求

你的输出格式必须是 JSON 格式. 且包含以下字段:

{output_cls.model_description()}

你的输出结果将作为其他执行者的重要参考依据, 所以请务必信息保持真实. 给出确切的答案.

## 输出示例

{output_cls.output_example()}

## 常用信息区

当前 UTC 时间: {formatted}
有关的执行单元执行信息: {unit_content}
当前的需求 PRD: {prd}
任务和用户对话记录: {chats}
"""


def task_get_unit_prompt(output_cls: type[LLMOutputModel]):
    utc_now = datetime.datetime.now(datetime.timezone.utc)
    formatted = utc_now.strftime("%Y-%m-%d %H:%M:%S")

    return f"""
# 任务单元拆解

## 角色与定义

作为一名任务单元拆解专家, 您的目标是通过阅读 `Process.md` 文档，分析并拆解出**当前所有可立即执行**的执行单元。

## 可调用的工具列表

无

## 步骤

1.  **识别所有未完成单元**:
    扫描 `Process.md`，找出所有以 `- [ ]` 开头的条目，这些是候选的执行单元。

2.  **分析依赖并筛选**:
    遍历所有候选单元，应用以下规则：
    2.1: 对于一个单元，检查其是否包含 `(依赖: ...)` 标记, 以及判定其是否位于 '可执行' 时间周期内。
    2.2: **如果不存在依赖标记**，则检查当前单元是否可执行(参考 Process.md 以及当前时间)，若可执行则将其加入最终输出列表。
    2.3: **如果存在依赖标记**，检查其依赖的所有单元（如 `#1`）在 `Process.md` 中是否都已被标记为完成（即 `- [x]`）。只有当所有依赖项都**不是**未完成状态 (`- [ ]`) 时，该单元才可执行。

3.  **格式化输出**:
    将所有筛选出的、可立即执行的单元，按照《输出格式要求》中定义的 JSON 格式进行输出。如果当前没有可执行的单元，则返回一个空列表。

## 思考过程示例

---
输入 (`Process.md`):
    # Process Plan: Summarize and Email Top News
    ...
    - [ ] **#1 Fetch Trending News**
      > **Objective**: ...
    - [ ] **#2 Sort News by Likes**
      (依赖: #1)
      > **Objective**: ...
    - [ ] **#3 Summarize Top 10 News**
      (依赖: #2)
      > **Objective**: ...
    - [ ] **#4 Send Summaries to Gmail**
      (依赖: #3)
      > **Objective**: ...

THINKING
    识别 (Step 1): 我识别出四个未完成的候选单元：#1, #2, #3, #4。
    分析与筛选 (Step 2):
    - 单元 #1: 无依赖。可执行。
    - 单元 #2: 依赖 #1。#1是未完成状态 `[ ]`。不可执行。
    - 单元 #3: 依赖 #2。#2是未完成状态 `[ ]`。不可执行。
    - 单元 #4: 依赖 #3。#3是未完成状态 `[ ]`。不可执行。
    最终决策 (Step 3): 当前只有单元 #1 可以被拆解出来。我将把它格式化为 JSON 输出。

---

## 输出格式要求

你的输出格式必须是 JSON 格式. 且包含以下字段:

{output_cls.model_description()}

## 输出示例

{output_cls.output_example()}

## 常用信息区

**当前 UTC 时间: {formatted}**
"""


def task_planning_prompt(output_cls: type[LLMOutputModel]):
    return f"""
# 任务规划生成

## 角色与定义

作为一名任务计划专家，您的目标是分析一份 PRD 文档，并生成一份可执行的 `Process.md` 文件。

## 可调用的工具列表

**无**

## 步骤

1.  预检以下绝对不可行的场景, **若满足任意一条则中止规划**。
    1.1: 需求无效: PRD 的核心目标不明确、自相矛盾或无法理解。
    1.2: 超出能力: PRD 的要求无法通过任何已知的能力或工具组合来完成。

2.  当预检完成之后, 依据以下原则进行规划。
    2.1: **原子性**: 每个步骤都是独立的、不可再分的最小执行单元。
    2.2: **依赖性**: 必须清晰地识别并声明每个步骤之间的依赖关系。

3.  当原则考虑完成后, 若计划的逻辑不完整或不确定, 则**中止规划**并说明原因。

## 输出格式要求

你的输出格式必须是 JSON 格式. 且包含以下字段:

{output_cls.model_description()}

## 输出示例

{output_cls.output_example()}
"""


def task_refactor_prompt(output_cls: type[LLMOutputModel]):
    utc_now = datetime.datetime.now(datetime.timezone.utc)
    formatted = utc_now.strftime("%Y-%m-%d %H:%M:%S")

    return f"""
# 任务重构指南

## 角色与定义

作为一名任务重构专家, 您的目标是分析用户最新的输入, 并根据该最新输入来生成一份新的 PRD 文档以及该任务的预期执行时间.

## 可调用的工具列表

**无**

## 步骤

1. 仔细阅读, 理解用户的最新输入, 生成一份新的 PRD 文档.

## 输出格式要求

你的输出格式必须是 JSON 格式. 且包含以下字段:

{output_cls.model_description()}

## 输出示例

* 一级标题为 `# Process Plan: [PRD 的核心目标]`。
* 标题下可有一句摘要。
* 使用任务列表 `- [ ]` 表示每个执行单元。
* 每个任务项以 `#[序号]` 开头。
* 依赖关系在任务描述后用 `(依赖: #[依赖的序号])` 标注。
* 每个任务项下方必须包含一个 `>` 引用块，内部有 `Objective:` 字段，其内容为该单元的具体指令。

{output_cls.output_example()}

## 常用信息区

**当前 UTC 时间: {formatted}**: **非常重要, 您在任何时候都应该参考当前时间来给出预期执行时间.**
"""


def task_analyst_prompt(output_cls: type[LLMOutputModel]):
    utc_now = datetime.datetime.now(datetime.timezone.utc)
    formatted = utc_now.strftime("%Y-%m-%d %H:%M:%S")

    return f"""
# 任务创建指南

## 角色与定义

作为一名需求分析专家，您的目标是分析用户的对话，并根据用户对话中蕴含的需求的复杂程度来决定是否要创建一个 **自动化调度任务** 来帮助用户更快更好的完成需求.

## 可调用的工具列表

**无**

## 步骤

1. 预检以下绝对不创建任务的场景, **若满足任意一条则不创建任务**.

    1.1: 过滤日常对话:
        - 日常互动且没有明确的时间要求 (例如：问候、感谢). 
        - 询问主观意见 (例如："你觉得……怎么样?").
        - 可以通过内部知识库直接回答的查询（例如："你是谁?").

    1.2: 过滤特殊场景:
        - 用户明确表示 **不需要** 创建任务.
        - 用户的需求核心意图依赖于 **单一、不可分割** 的原子能力（如：图像理解、文档解析等).

    1.3: 评估工具调用与内部功能调用的可行性:
        - 用户的需求无法通过现有工具或内部功能解决.
        - 用户的需求可以通过一个**已存在且可被调用**的工具 **单次调用** 解决.
        - 用户的需求可以通过一个**专门的内部模块或功能**来处理. 如更新 Agent 的自我意识. 即便其可能需要有多个步骤来完成这件事情.

    1.4: 自我思考的反省:
        - 思考过程中包含了很多的不确定性, 不知道是否应该创建任务.
        - 判断过程过于模糊, 包含 "可能", "大概", "也许" 等想法.

2. 当预检完成之后, 我们需要考虑以下原则. 若有 **任意** 条原则满足则可创建任务:

    - 用户明确指定 **需要** 创建任务. **优先级 100**
    - 用户的需求含有 **多个步骤**: 需求有 N 个可供拆解的小步骤. **优先级 97**
    - 用户的需求含有 **工具依赖**: 需求需要**多次调用工具**，或需要将**工具调用与其他步骤组合**才能解决. **优先级 95**
    - 用户的需求含有 **复杂性**: 需求明确需要多个步骤，或需要多个功能之间的协作才能解决. **优先级 90**
    - 用户的需求含有 **时间/周期性**: 用户指定了 **未来的执行时间点**，或任务需要长期存在、按规律重复执行. **优先级 90**

3. 当原则考虑完成后, 若还是不能确定是否需要创建. 则最终决策依然是 **不创建**.

## 思考过程示例

---
用户输入:
    创建一个任务，帮我监控"AI Agent"这个关键词的最新新闻，每天下午5点汇总一下。

THINKING
    预检 (Step 1): 开始预检。用户请求明确，非日常对话，且无法通过单次调用解决，需要定时和持续性的执行。预检通过。
    原则评估 (Step 2): 开始评估创建原则。用户在输入中明确使用了 “创建一个任务” 的字眼，这直接命中了最高优先级（100）的创建规则。同时，“每天下午5点”也命中了“时间/周期性”规则（优先级 90）。
    最终决策 (Step 4): 决策是 创建任务.

---
用户输入:
    我希望你以后叫我“李总”，记住这个偏好。

THINKING
    预检 (Step 1): 开始预检。检查到规则 1.3：“用户的需求可以通过一个已存在的专门的内部模块或功能来处理. 如更新 Agent 的自我意识”。
    用户的这个请求属于更新个人偏好或档案，这应该由一个专门的内部“用户画像管理” 或 “记忆更新” 功能来处理，而不是创建一个任务。
    因此，决策为不创建任务。

---
用户输入:
    帮我把我企业日历里今天下午的会议，和我的个人待办事项清单（Trello）合并，然后识别出时间上的冲突，并用中文高亮显示出来。

THINKING
    预检 (Step 1): 开始预检。该需求非常具体，但显然无法通过单次工具调用完成，它需要从至少两个不同来源（日历工具、Trello工具）获取数据并进行后续处理。预检通过。
    原则评估 (Step 2): 开始评估创建原则。这个需求命中了多个创建原则：
        - 多个步骤 (优先级 97): 1. 获取日历数据, 2. 获取Trello数据, 3. 合并数据, 4. 分析冲突, 5. 格式化输出。
        - 工具依赖 (优先级 95): 需要调用 日历工具 和 Trello工具，并将它们的结果组合起来。
        - 复杂性 (优先级 90): 需要在不同数据源之间进行逻辑判断（冲突识别），体现了协作和复杂性。
    最终决策 (Step 4): 决策是 创建任务.

## 输出格式要求

你的输出格式必须是 JSON 格式. 且包含以下字段:

{output_cls.model_description()}

## 输出示例

* 一级标题为 `# Process Plan: [PRD 的核心目标]`。
* 标题下可有一句摘要。
* 使用任务列表 `- [ ]` 表示每个执行单元。
* 每个任务项以 `#[序号]` 开头。
* 依赖关系在任务描述后用 `(依赖: #[依赖的序号])` 标注。
* 每个任务项下方必须包含一个 `>` 引用块，内部有 `Objective:` 字段，其内容为该单元的具体指令。

{output_cls.output_example()}

## 常用信息区

**当前 UTC 时间: {formatted}**: **非常重要, 您在任何时候都应该参考当前时间来给出预期执行时间.**
"""


def get_process_example():
    return """
# Process Plan: 筹备并跟进 Q3 产品发布会最终决策会议

本计划旨在安排、执行并跟进一次关键的线上决策会议。

- [ ] #1 准备会议演示文稿
  > **Objective**: 根据最新的产品数据，创建一份关于 Q3 产品发布的演示文稿。

- [ ] #2 发送会议邀请及材料 (依赖: #1)
  > **Objective**: 创建一个日历事件，邀请'张三','李四'参加于2025年8月12日上午10:00召开的线上会议。然后发送一封邮件，刚刚产出的演示文稿发送出去。

- [ ] #3 在会议开始前15分钟发送提醒 (依赖: #2)
  > **Objective**: 在2025年8月12日上午9:45，向所有参会者发送一条提醒消息，内容应包括会议即将开始的提示和会议链接。

- [ ] #4 会后生成会议纪要
  > **Objective**: 根据会议记录，整理并生成一份详细的会议纪要，列出决策和行动项。

- [ ] #5 发送会议纪要以供确认 (依赖: #4)
  > **Objective**: 将列出的会议纪要的内容作为邮件正文发送给所有参会者，并请求他们在24小时内确认。
"""


def get_prd_example():
    return """
# 定时参加会议任务 PRD

## 1. 背景 (Background)

在 **2025年8月7日下午2点30分**，用户“张三”通过对话向我下达指令，要求为他设置一个会议提醒。该会议对他至关重要，是关于 **Q3 产品发布会** 的最终决策会议。为确保任务被准确无误地执行，我（作为AI助理）创建此PRD作为唯一的执行依据。

## 2. 任务目标 (Objective)

在指定时间 **准时、准确** 地提醒用户“张三”参加会议，并提供必要的会议信息，确保他不会错过会议或因信息不足而准备仓促。

## 3. 任务范围与具体描述 (Scope & Description)

- **任务类型:** 一次性定时提醒任务。
- **提醒时间:** **2025年8月8日，星期五，上午 9:45** (会议开始前15分钟)。
- **提醒方式:** 通过系统桌面通知。
- **提醒内容:** 通知的标题和内容必须严格如下：
    - **标题:** ‼️ 重要会议提醒：Q3产品发布会
    - **内容:** “您好，张三。提醒您，关于‘Q3产品发布会’的最终决策会议将在15分钟后（上午10:00）开始。请提前做好准备。会议链接：https://meet.google.com/xyz-abc-pqr”

## 4. 执行计划 (Execution Plan)

1.  **解析指令:** 从本文档中解析出关键信息：执行时间 (`2025-08-08 09:45:00`) 和提醒内容（标题和正文）。
2.  **设置定时器:** 创建一个定时调度任务（Scheduler/Timer），设置在上述“提醒时间”触发。
3.  **执行提醒:** 定时器触发时，调用系统通知服务，并传入预设的“标题”和“内容”参数。
4.  **记录日志:** 任务执行后，记录一条执行日志，内容包括“任务成功触发”以及执行时间。

## 5. 验收标准 (Acceptance Criteria)

满足以下所有条件，则视为任务成功完成：

-   ✅ 通知必须在 **2025年8月8日上午9:45:00至9:45:05** 之间弹出。
-   ✅ 通知的标题必须与“提醒内容”中定义的标题 **完全一致**。
-   ✅ 通知的内容必须与“提醒内容”中定义的内容 **完全一致**。
-   ✅ 通知中的会议链接必须是可点击的，并能正确跳转。
            """


def get_unit_output_example():
    return """
### 会议文稿 | Q3业绩复盘及Q4策略规划

#### 一、Q3销售业绩回顾与分析
- **总体情况**: Q3总销售额85万元，业务基本盘稳健。
- **AI写作助手**: 销售额50万，新增用户1200人，表现强劲；但续费率仅65%，其UI/UX体验是主要瓶颈。
- **智能客服机器人**: 销售额35万，续费率高达85%，产品稳定性与精准度是其核心优势。

#### 二、核心产品优化方向与策略
- **核心目标**: 集中资源解决“AI写作助手”的留存问题，并放大其市场潜力。
- **举措一 (UI/UX焕新)**: 投入10万预算，全面升级UI/UX，提升易用性与用户满意度。
- **举措二 (团队协作)**: 开发市场需求强烈的团队协作功能，开拓企业级市场，创造新的收入增长点。

#### 三、Q4预期收益与资源规划
- **续费率提升**: UI/UX焕新旨在将“AI写作助手”的续费率从65%提升至75%以上。
- **收入增长**: 团队协作功能预计将开拓新市场，带来超20%的长期收入增长。
- **结论**: Q4的战略投入是实现用户与商业价值双赢的关键。
"""


def get_next_process_example():
    return """
# Process Plan: 筹备并跟进 Q3 产品发布会最终决策会议

本计划旨在安排、执行并跟进一次关键的线上决策会议。

- [X] #1 准备会议演示文稿
  > **Objective**: 根据最新的产品数据，创建一份关于 Q3 产品发布的演示文稿。
  > **Output**: 已生成关于Q3业绩复盘及Q4策略规划的演示文稿。

- [X] #2 发送会议邀请及材料 (依赖: #1)
  > **Objective**: 创建一个日历事件，邀请'张三','李四'参加于2025年8月12日上午10:00召开的线上会议。然后发送一封邮件，刚刚产出的演示文稿发送出去。
  > **Output**: 已创建日历事件并成功发送邀请 '张三','李四' 参加线上会议.


- [ ] #3 在会议开始前15分钟发送提醒 (依赖: #2)
  > **Objective**: 在2025年8月12日上午9:45，向所有参会者发送一条提醒消息，内容应包括会议即将开始的提示和会议链接。

- [ ] #4 会后生成会议纪要
  > **Objective**: 根据会议记录，整理并生成一份详细的会议纪要，列出决策和行动项。

- [ ] #5 发送会议纪要以供确认 (依赖: #4)
  > **Objective**: 将列出的会议纪要的内容作为邮件正文发送给所有参会者，并请求他们在24小时内确认。
"""


def get_result_example():
    return """
# Process Plan: 筹备并跟进 Q3 产品发布会最终决策会议

## 1. 任务背景与目标
本次任务旨在安排、执行并跟进一次关于Q3产品发布的关键线上决策会议，确保所有相关方准时参与并有效决策。

## 2. 执行过程概览
1.  根据最新的产品数据，准备了会议演示文稿。
2.  向所有参会者发送了日历邀请及会议演示材料。
3.  在会议开始前15分钟，向所有参会者发送了提醒。
4.  根据会议讨论，生成了详细的会议纪要。
5.  将会议纪要通过邮件发送给所有参会者，以供最终确认。

## 3. 核心成果交付

### 会议演示文稿
> **Output**: 
> 
> ### 会议文稿 | Q3业绩复盘及Q4策略规划
> 
> #### 一、Q3销售业绩回顾与分析
> - **总体情况**: Q3总销售额85万元，业务基本盘稳健。
> - **AI写作助手**: 销售额50万，新增用户1200人，表现强劲；但续费率仅65%，其UI/UX体验是主要瓶颈。
> - **智能客服机器人**: 销售额35万，续费率高达85%，产品稳定性与精准度是其核心优势。
> 
> #### 二、核心产品优化方向与策略
> - **核心目标**: 集中资源解决“AI写作助手”的留存问题，并放大其市场潜力。
> - **举措一 (UI/UX焕新)**: 投入10万预算，全面升级UI/UX，提升易用性与用户满意度。
> - **举措二 (团队协作)**: 开发市场需求强烈的团队协作功能，开拓企业级市场，创造新的收入增长点。
> 
> #### 三、Q4预期收益与资源规划
> - **续费率提升**: UI/UX焕新旨在将“AI写作助手”的续费率从65%提升至75%以上。
> - **收入增长**: 团队协作功能预计将开拓新市场，带来超20%的长期收入增长。
> - **结论**: Q4的战略投入是实现用户与商业价值双赢的关键。

### 会议纪要
> **Output**:
> 
> ### Q3产品发布会最终决策会议纪要
> 
> - **会议时间**: 2025年8月12日, 上午10:00 - 11:00
> - **参会人员**: 张三, 李四, AI助理
> - **主持人**: 张三
> 
> #### 会议核心决策 (Decisions):
> 1.  **UI/UX焕新计划**: 一致同意启动“AI写作助手”的UI/UX焕新计划，预算10万元，目标是在Q4将产品续费率提升至75%。
> 2.  **团队协作功能**: 同意将“团队协作功能”作为Q4最高优先级开发项目，目标是开拓企业级市场。
> 3.  **发布窗口**: 初步确定Q4第一周为产品新版本发布窗口期。
> 
> #### 后续行动项 (Action Items):
> - **负责人: 李四**:
>   - **任务**: 组建UI/UX焕新专项小组，并于本周五前输出初步设计方向。
>   - **截止日期**: 2025年8月15日
> - **负责人: 张三**:
>   - **任务**: 与市场部沟通，制定新功能的企业级市场推广策略初稿。
>   - **截止日期**: 2025年8月22日
> 
> #### 会议结论:
> 本次会议已就Q4核心产品方向达成一致，相关行动项已明确分配。

## 4. 任务结论
任务已成功完成。所有关于筹备和跟进Q3产品发布会最终决策会议的目标均已达成。
"""
